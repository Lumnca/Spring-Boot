# :golf:应用开发  #

<b id="t"></b>

:arrow_double_down:[邮件发送](#a1)

:arrow_double_down:[定时任务](#a2)

:arrow_double_down:[批处理](#a3)

:arrow_double_down:[Swagger2](#a4)

:arrow_double_down:[数据校检](#a5)

:arrow_double_down:[Ftp整合](#a6)

<b id="a1"></b>

### :bowling:邮件发送 ###

:arrow_double_up: [返回目录](#t)

邮件发送是一个常用的功能，包括注册时的身份验证，重要通知发送都是都会用到邮件发送。Sun公司提供了JavaMail用来实现邮件发送，但是配置烦琐，Spring中提供了
简化邮箱的配置，下面来看看怎么配置邮件发送：

这里以QQ邮箱为例，首先需要开通POP3/STMP服务或者IMAP/STMP服务，如下：

首先到你的QQ邮箱主页设置开启协议（在设置的账户里面）

![](https://github.com/Lumnca/Spring-Boot/blob/master/img/a31.png)

然后往下翻，到协议设置里开启协议，如下：

![](https://github.com/Lumnca/Spring-Boot/blob/master/img/a32.png)


根据操作会让你发送短信验证，得到验证过后，会给你一个授权码，保存好授权码，后面配置需要使用。

接下来就是搭建环境，引入依赖：

```xml
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>
    </dependencies>
```

修改配置文件参数：

```java
spring.mail.host=smtp.qq.com
spring.mail.port=587
spring.mail.username=724119519@qq.com   --QQ用户名
spring.mail.password=tubzuigsfubqbdjh   --验证码
spring.mail.default-encoding=UTF-8
spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory
spring.mail.properties.mail.debug=true;
```

配置发送邮件的方法

```java
@Component
public class MailServer {
    @Autowired
    JavaMailSender javaMailSender;
    public void sendSimpleMail(String from,String to,String cc,String subject,String content){
        SimpleMailMessage message = new SimpleMailMessage();
        message.setFrom(from);
        message.setTo(to);
        message.setCc(cc);
        message.setSubject(subject);
        message.setText(content);
        javaMailSender.send(message);
    }
}
```

* JavaMailSender 是Spring Boot在MailSenderPropertiesConfiguration类中配置好的，该类在Mail自动配置类MailSenderAutoConfiguration 中导入，因此这里注入JavaMailSender就可以使用了。

* sendSimpleMail方法的5个参数分别表示邮件发送者、收件人、抄送人、邮件主题以及邮件内容。

* 简单邮件可以直接构建一个SimpleMailMessage对象进行配置，配置完成后，通过JavaMailSender将邮件发送出去。

然后添加一个测试即可：

```java
@Controller
public class index {

    @Autowired
    MailServer mailServer;
    @GetMapping("/send")
    public String send(){
        mailServer.sendSimpleMail("724119519@qq.com","1050603098@qq.com","724119519@qq.com",
                "消息推送","测试邮件内容:\n"+new Date().toString()+"发送通知，系统消息。");

        return "发送邮件成功";
    }
}
```

注意信息配置要正确，用户名，发送者，接受者，验证码要正确。

**发送带附件的邮件**

要发送附件需要添加额外的配置：

```java
@Component
public class MailServer {
    @Autowired
    JavaMailSender javaMailSender;
    public void sendSimpleMail(String from, String to, String cc, String subject, String content, File file){

        try {
            MimeMessage mimeMessage = javaMailSender.createMimeMessage();
            MimeMessageHelper message = new MimeMessageHelper(mimeMessage,true);
            message.setFrom(from);
            message.setTo(to);
            message.setCc(cc);
            message.setSubject(subject);
            message.setText(content);
            message.addAttachment(file.getName(),file);
            javaMailSender.send(mimeMessage);
        }
        catch (Exception e){
            e.printStackTrace();
        }

    }
}
```

最后添加一个邮件文件即可：

```java
@Controller
public class index {

    @Autowired
    MailServer mailServer;
    @GetMapping("/send")
    public String send(){
        mailServer.sendSimpleMail("724119519@qq.com","1050603098@qq.com","724119519@qq.com",
                "消息推送","测试邮件内容:\n"+new Date().toString()+"发送通知，系统消息。",new File("F:\\实验室\\a30.png"));
        return "发送邮件成功";
    }
}
```

**发送带图片的资源的邮件**

有的邮件可能需要图片邮件，使用FileSystemResource就可以实现：

```java
@Component
public class MailServer {
    @Autowired
    JavaMailSender javaMailSender;
    public void sendSimpleMail(String from, String to, String subject, String content,
                               String[] srcPath,String[] redIds){
        if(srcPath.length != redIds.length){
            System.out.println("发送失败");
            return;
        }
        try {
            MimeMessage message = javaMailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message,true);
            helper.setFrom(from);
            helper.setTo(to);
            helper.setSubject(subject);
            helper.setText(content,true);   //第二个参数开启HTML内容发送
            for (int i=0;i < srcPath.length;i++){
                FileSystemResource resource = new FileSystemResource(new File(srcPath[i]));
                helper.addInline(redIds[i],resource);
            }
            javaMailSender.send(message);
        }
        catch (MessagingException e){
            e.printStackTrace();
            System.out.println("发送失败");
        }
    }
}
```

接下来就是控制器：

```java
    @Autowired
    MailServer mailServer;
    @GetMapping("/send")
    public void send(HttpServletResponse response ){
        mailServer.sendSimpleMail("724119519@qq.com","1050603098@qq.com","测试邮件带图片发送",
                "<div>测试图片一</div><div><img src='cid:p01'></div>" +
                        "<div>测试图片二</div><div><img src='cid:p02'></div>",
                new String[]{"F:\\实验室\\a28.png","F:\\实验室\\a29.png"},new String[]{"p01","p02"});
        System.out.println("发送成功！");
    }
```

其中cid为静态文件路径配置，其中参数配置了文件路径。

当然可以使用Html模板来构建邮件模板。

<b id="a2"></b>

### :bowling:定时任务 ###

:arrow_double_up: [返回目录](#t)

定时任务也是常见的开发应用之一，定时发送信息，执行某些操作十分重要。简单的定时操作可以直接由注解@Scheduled注解来实现，复杂的定时任务则是由集成Quartz来实现。

**Scheduled**

@Scheduled注解使用简单，如下：

在项目启动类上开启定时启动注解@EnableScheduling

```java
@SpringBootApplication
@EnableScheduling
public class start {
    public static  void main(String[] args){
        SpringApplication.run(start.class,args);
    }
}
```


定时任务主要通过@Scheduled注解进行配置，如下：

```java
    @Scheduled(fixedDelay = 1000)
    public void  printf(){
        System.out.println("定时打印信息");
    }
```

注意方法可以在任何地方执行，不需要调用，一旦开启注解，就会执行。fixedDelay为定时时间，单位毫秒。可以设置开始延迟时间：

```java
    @Scheduled(fixedDelay = 1000,initialDelay = 5000)
    public void  printf(){
        System.out.println("定时打印信息");
    }
```

initialDelay代表开始的延迟时间。当然也可以使用cron表达式来：

```java
    @Scheduled(cron = "0 * * * * ?")
    public void  printf(){
        System.out.println("定时打印信息");
    }
```

**Quatrz**

Quatrz是一个功能丰富的开源作业调度库，它由Java写成，可以集成在任何的Java应用程序中，使用Quatrz可以创建复杂或者简单的执行计划，它又支持数据库，集群，插件以及邮件，并且支持cron表达式，具有极高的灵活性。下面介绍其使用方法：

添加依赖：

```xml
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-quartz</artifactId>
        </dependency>
    </dependencies>
```

创建Job：

```java
public class MyJob  extends QuartzJobBean {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    protected void executeInternal(JobExecutionContext context){
        System.out.println("用户："+name+"打印日期:"+new Date());
    }
}
```

这是不使用注解，而是继承 QuartzJobBean抽象类，当然也可以使用普通类并添加注解@Component，但是这样不能够传递方法参数，推荐使用这种方式。其中 executeInternal方法是任务被调用是启动，name属性在配置文件中配置，接下来完成配置文件：

```java
@Configuration
public class QuartzConfig {
   /*
   *普通类Bean调用方式
   @Bean
    MethodInvokingJobDetailFactoryBean jobDetailFactoryBean1(){
        MethodInvokingJobDetailFactoryBean factoryBean = new MethodInvokingJobDetailFactoryBean();
        factoryBean.setTargetBeanName("MyJob");
        factoryBean.setTargetMethod("printf");
        return factoryBean;
    }*/
    @Bean
    JobDetailFactoryBean jobDetailFactoryBean2(){
        JobDetailFactoryBean bean = new JobDetailFactoryBean();
        bean.setJobClass(MyJob.class);         //--获取执行类
        JobDataMap jobDataMap = new JobDataMap();   //添加参数字段
        jobDataMap.put("name","sang");      
        bean.setJobDataMap(jobDataMap);
        bean.setDurability(true);
        return  bean;
    }
    //---定时操作
    @Bean
    SimpleTriggerFactoryBean simpleTriggerFactoryBean(){
        SimpleTriggerFactoryBean bean = new SimpleTriggerFactoryBean();
        bean.setJobDetail(jobDetailFactoryBean2().getObject());
        bean.setRepeatCount(3);          //执行3次
        bean.setStartDelay(2000);        //任务启动延迟时间
        bean.setRepeatInterval(1000);    //循环调用时间间隔
        return  bean;
    }
    /*
    cron表达式用法
    @Bean
    CronTriggerFactoryBean cronTriggerFactoryBean(){
        CronTriggerFactoryBean bean = new CronTriggerFactoryBean();
        bean.setJobDetail(jobDetailFactoryBean2().getObject());
        bean.setCronExpression("* * * * * ?");
        return bean;
    }
    */
    //添加任务配置
    @Bean
    SchedulerFactoryBean schedulerFactoryBean(){
        SchedulerFactoryBean bean = new SchedulerFactoryBean();
        SimpleTrigger simpleTrigger = simpleTriggerFactoryBean().getObject();  
        bean.setTriggers(simpleTrigger);  //--计时方法配置参数，可多个
        return bean;
    }
}

```

启动运行就可以看到控制台打印3条信息。

<b id="a3"></b>

### :bowling:批处理 ###

:arrow_double_up: [返回目录](#t)

Spring Batch是一个开源的、全面的、轻量级的批处理框架，通过Spring Batch可以实现强大的批处理应用程序的开发。Spring Batch还提供记录/跟踪、事务管理、作业处理统计、作业重启以及资源管理等功能。Spring Batch结合定时任务可以发挥更大的作用。
Spring Batch 提供了ltemReader、ItemProcessor和ltemWriter来完成数据的读取、处理以及写出操作，并且可以将批处理的执行状态持久化到数据库中。接下来通过一个简单的数据复制展示Spring Boot中如何使用Spring Batch。

**整合Spring Boot**

现在有一个data.csv文件，文件件中保存了4条数据，通过批处理框架读取data.csv，将之插入数据表中，首先添加依赖：

```xml
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-batch</artifactId>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid</artifactId>
            <version>1.1.9</version>
        </dependency>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.1.21</version>
        </dependency>
    </dependencies>
```

修改配置文件

```java
spring.datasource.url=jdbc:mysql://47.106.254.86/ex?characterEncoding=utf8&useSSL=true
spring.datasource.username=lumnca
spring.datasource.password=chuan868
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
spring.datasource.driver-class-name=com.mysql.jdbc.Driver

spring.datasource.schema=classpath:/org/springframework/batch/core/schema-mysql.sql  --获取自动脚本

spring.batch.initialize-schema=always 
spring.batch.job.enabled=false   --自动化配置，需要手动执行
```

添加注解@EnableBatchProcessing  对Spring Batch支持

```java
@SpringBootApplication
@EnableBatchProcessing  
public class start {
    public static  void main(String[] args){
        SpringApplication.run(start.class,args);
    }
}
```

首先配置插入数据库的实体类(数据库字段为"id", "username","address","gender")：

```java

public class User {
    private Integer id;
    private String username;
    private String address;
    private String gender;

    public User(){

    }
    public User(Integer _id,String _username,String _address,String _gender){
        id = _id;
        username = _username;
        address = _address;
        gender = _gender;
    }
    public void setUsername(String username) {
        this.username = username;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public Integer getId() {
        return id;
    }

    public String getAddress() {
        return address;
    }

    public String getGender() {
        return gender;
    }

    public String getUsername() {
        return username;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }
}

```

需要插入的data.csv文件：

```csv
id username address gender
1 张三 深圳 男
2 李四 广州 男
3 王五 上海 男
4 陆露 北京 女
```


配置批处理代码：

```java
@Configuration
@EnableBatchProcessing
public class BatchConfiguration {
    @Autowired
    public JobBuilderFactory jobBuilderFactory;

    @Autowired
    public StepBuilderFactory stepBuilderFactory;

    @Autowired
    public DataSource dataSource;

    @Bean
    public FlatFileItemReader<User> reader() {
        FlatFileItemReader<User> reader = new FlatFileItemReader<User>();
        reader.setResource(new ClassPathResource("data.csv"));  //文件所在位置位于resource目录下的data.csv
        reader.setLinesToSkip(1);                               //跳过第一行，因为第一行为表头，不是插入的内容
        reader.setLineMapper(new DefaultLineMapper<User>() {
            {
                setLineTokenizer(new DelimitedLineTokenizer() {
                    {
                        setNames("id", "username","address","gender");  //字段信息，全部添加
                        setDelimiter(" ");                              //字段分隔符，在data.csv文件中以空格隔开
                    }
                });
                setFieldSetMapper(new BeanWrapperFieldSetMapper<User>() {
                    {
                        setTargetType(User.class);    //对应实体类
                    }
                });
            }
        });
        return reader;
    }
    //批处理监听器
    @Bean
    public UserItemProcessor processor() {
        return new UserItemProcessor();
    }
    @Bean
    public JdbcBatchItemWriter<User> writer() {
        JdbcBatchItemWriter<User> writer = new JdbcBatchItemWriter<>();
        writer.setItemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider<>());
        writer.setSql("INSERT INTO user (id,username,address,gender) VALUES (:id,:username,:address,:gender)"); //插入数据库操作，:字段即代表对应字段
        writer.setDataSource(dataSource);
        return writer;
    }
    //作业配置
    @Bean
    public Job importUserJob(JobCompletionNotificationListener listener) {
        return jobBuilderFactory.get("importUserJob")  //对应自己名称
                .incrementer(
                new RunIdIncrementer())
                .listener(listener)
                .flow(step1())
                .end()
                .build();
    }
    @Bean
    public Step step1() {
        return stepBuilderFactory.get("step1")   //对应自己名称
                .<User, User>chunk(2)    //一次性读取2条信息
                .reader(reader())        //读操作绑定
                .processor(processor())  //监听绑定
                .writer(writer())        //写绑定
                .build();              
    }
}

```


接下来就是监听器处理：

```java
public class UserItemProcessor implements ItemProcessor<User, User> {
    private static final Logger log = LoggerFactory.getLogger(UserItemProcessor.class);

    @Override
    public User process(final User user) throws Exception {
        final Integer id = user.getId();
        final String gender = user.getGender();
        final String username = user.getUsername();
        final String address = user.getAddress();
        final User transformedPerson = new User(id,username,address,gender);

        log.info("插入一条数据："+user.getId()+" " + user.getUsername() +" "+ user.getAddress()+" "+user.getGender());
        return transformedPerson;
    }
}
```

已经批处理作业监听器：

```java
@Component
public class JobCompletionNotificationListener extends JobExecutionListenerSupport {
    private static final Logger log = LoggerFactory.getLogger(JobCompletionNotificationListener.class);
    private final JdbcTemplate jdbcTemplate;

    @Autowired
    public JobCompletionNotificationListener(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }
    @Override
    public void afterJob(JobExecution jobExecution) {
        //开始执行触发
        if (jobExecution.getStatus() == BatchStatus.STARTING){
            log.info("开始执行");
        }
        //完成触发
        eles if (jobExecution.getStatus() == BatchStatus.COMPLETED) {
            log.info("添加完成！！！数据报告如下");

            List<User> results = jdbcTemplate.query(
                    "SELECT * FROM user", new RowMapper<User>() {
                        @Override
                        public User mapRow(ResultSet rs, int row) throws SQLException {
                            return new User(rs.getInt(1), rs.getString(2),rs.getString(3),rs.getString(4));
                        }
                    });

            for (User person : results) {
                log.info("在数据库中找到了一条数据：" + person.getUsername() +" "+ person.getAddress()+" "+person.getGender());
            }
        }
    }
}
```

由于我们前面配置的是手动启用这个批处理，所以需要我们自己启动：

```java
@Controller
public class index {
    @Autowired
    JobLauncher jobLauncher;
    @Autowired
    Job job;
    @GetMapping("/hello")
    public String hello(){
        try {
            jobLauncher.run(job,
            new JobParametersBuilder().addString(new Date().toString(),"xxx").toJobParameters());
        }
        catch (Exception e){
            e.printStackTrace();
        }
        finally {
           System.out.println("操作完成！");
        }
        return "Success";
    }
}
```


值得注意的是这里的 jobLauncher.run是启用批处理，这里参数必须添加，参数为键值对，是在批处理中调用的，如果不使用的话，这里可以写任意的键值对，但是键值对的key要保证每次调用都不同，因为作业调度要唯一，这个也是区别不同作业键值对。当然把前面配置文件的spring.batch.job.enabled=false改为ture，就可以在项目启动时自动启用，在数据库中创建好对应的user表，执行接口`http://localhost:8080/hello`看到如下信息：

![](https://github.com/Lumnca/Spring-Boot/blob/master/img/a33.png)

其中包括日志打印信息和我们刚才添加的键值对。

在数据中也能看到对应的数据：

![](https://github.com/Lumnca/Spring-Boot/blob/master/img/a34.png)

至此简单的批处理使用就到这里了，如果想使用高级配置还是比较复杂，可以在网上查找。

<b id="a4"></b>

### :bowling:Swagger2 ###

:arrow_double_up: [返回目录](#t)

在前后端分离开发中，为了减少与其他团队的沟通成本，一般构建一份RESful API文档来描述所有接口信息，但是这种做法有很大的弊端。Swagger2是一个开源软件框架
可以帮助开发人员设计使用，构建，记录和使用RESful Web服务它将代码和文档融为一体，可以完美解决上面的问题。使开发更加便捷。

添加依赖：

```xml
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
            <version>2.9.2</version>
        </dependency>
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger-ui</artifactId>
            <version>2.9.2</version>
        </dependency>
    </dependencies>
```


创建Swagger2配置类：

```java
@Configuration
@EnableSwagger2  //开启Swagger注解
public class SwaggerConfig {
    @Bean
    Docket docket(){
        return new Docket(DocumentationType.SWAGGER_12)   
                .select()
                .apis(RequestHandlerSelectors.basePackage("run"))          //扫描控制器接口的包路径
                .paths(PathSelectors.any())
                .build().apiInfo(new ApiInfoBuilder()
                .description("接口测试文档")                                      //文档命名与地址链接版本信息，标题等信息，可随意
                .contact(new Contact("Lumnca","https://github.com/lumnca","" +
                        "lumnca@gmail.com"))
                .version("V1.1.0")              
                .title("API测试文档")
                .license("Apache2.0")
                .licenseUrl("http://www.apache.org/licenses/LICENSE-2.0")
                .build());
    }
}
```


接下来就可以直接添加接口了，注意上面的接口配置类的包在run下，所以我的接口也应该建立在此之下。创建接口：

```java
@RestController
@Api(tags = "用户数据接口")      //接口信息
public class index {
    @ApiOperation(value = "查询用户",notes = "根据ID查询用户")
    @ApiImplicitParam(paramType = "path",name = "id",value = "用户ID",required = true,defaultValue = "5")
    @GetMapping("/user/{id}")
    public String getUserById(@PathVariable Integer id){
        return "/user"+id;
    }

    @ApiResponses({
            @ApiResponse(code = 200,message = "删除成功！"),
            @ApiResponse(code = 500,message = "删除失败")
    })
    @ApiOperation(value = "删除用户",notes = "通过id删除用户")
    @DeleteMapping("/user/{id}")
    public Integer deleteById(Integer id){
        return  id;
    }

    @ApiResponses({
            @ApiResponse(code = 200,message = "操作成功！"),
            @ApiResponse(code = 404,message = "操作未找到！"),
            @ApiResponse(code = 500,message = "操作失败！")
    })
    @ApiOperation(value = "添加用户",notes = "提供全参数",produces = "JSON")
    @PostMapping("/user/add")
    public String addUser(@RequestBody User info){
        return info.getUsername();
    }
    @ApiIgnore
    public void user(){

    }
}
```

对于上面的注解@ApiOperation用于方法之上，代表对方法接口进行描述，其中value就是描述信息，notes是详细信息。

@ApiImplicitParam注解是参数描述信息(paramType是指方法参数的类型，可选择值有path（参数获取方式@PathVariable），query（参数获取方式@RequestParam），header（参数方法是@RequestHeader），body（@@RequestBody）等来描述，默认自动匹配，required = true表示该字段必须填写，defaultValue表示该字段的默认值。

 @ApiResponses是对接口响应结果进行描述，code为响应码，message为对应的信息。
 
 @ApiIgnore表示不对该方法进行描述。
 
 如果想对实体类进行描述可以添加实体类描述注解：
 
 ```java
 @ApiModel(value = "用户实体类",description = "用户信息描述类")       //实体类注解
public class User {
    @ApiModelProperty(value = "用户ID")       //属性字段信息
    private Integer id;
    @ApiModelProperty(value = "用户名")
    private String username;
    @ApiModelProperty(value = "用户地址")
    private String address;
    @ApiModelProperty(value = "用户性别")
    private String gender;

    public User(){

    }
    public User(Integer _id,String _username,String _address,String _gender){
        id = _id;
        username = _username;
        address = _address;
        gender = _gender;
    }
    public void setUsername(String username) {
        this.username = username;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public Integer getId() {
        return id;
    }

    public String getAddress() {
        return address;
    }

    public String getGender() {
        return gender;
    }

    public String getUsername() {
        return username;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }
}

 ```


完成后，在浏览器地址栏输入`http://localhost:8080/swagger-ui.html`即可以看到接口文档。如下

![](https://github.com/Lumnca/Spring-Boot/blob/master/img/a35.png)

打开接口和实体类信息如下：

![](https://github.com/Lumnca/Spring-Boot/blob/master/img/a36.png)

打开方法输入参数界面：

![](https://github.com/Lumnca/Spring-Boot/blob/master/img/a37.png)

点击执行按钮看到响应信息：

![](https://github.com/Lumnca/Spring-Boot/blob/master/img/a38.png)

<b id="a5"></b>

### :bowling:数据校检 ###

:arrow_double_up: [返回目录](#t)

数据校检是一个常用的开发环节，一般来说，为了提高系统运行效率，都会在前端进行数据校检，但是并不是所有数据都需要在前端校检，因为用户还是可能在取数据接口后传入非法数据，所以后端还是需要做数据验证，Spring Boot对此进行了相关的自动化配置，如下介绍：


添加依赖：

```xml
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
    </dependencies>
```

由于默认的配置信息是需要在resource目录下创建ValidationMessages.properties文件来显示错误信息的，所以先创建一个ValidationMessages.properties文件然后添加错误返回信息：

```java
user.name.size=用户名长度只能在5到10
user.email.notnull=邮箱不能为空
user.age.size=年龄范围只能在1~150
user.email.pattern=邮箱格式不正确
```

这些数据是由后面的配置调取的，如下在实体类中绑定数据验证信息：

```java
public class User {

    private Integer id;
    @Size(min = 5,max = 10,message = "{user.name.size}")
    private String username;
    @NotNull(message = "{user.address.notnull}")
    @Email(message = "{user.email.pattern}")
    private String email;
    @DecimalMin(value = "1",message = "{user.age.size}")
    @DecimalMax(value = "150",message = "{user.age.size}")
    private Integer age;
    public User(){

    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Integer getAge() {
        return age;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public Integer getId() {
        return id;
    }
    
    public String getUsername() {
        return username;
    }
    
    public void setEmail(String email) {
        this.email = email;
    }

    public String getEmail() {
        return email;
    }
}
```

其中@Size是字符长度限定。 @NotNull为不能为空，@DecimalMin，@DecimalMax分别为最大最小值，@Email是要为邮箱格式。

接下来添加接口：

```java
public class index {
    @PostMapping("/user")
    public List<String> addUser(@Validated User user, BindingResult result){
        List<String> errors = new ArrayList<>();
        if(result.hasErrors()){
            List<ObjectError> allErrors= result.getAllErrors();
            for(ObjectError oe : allErrors){
                errors.add(oe.getDefaultMessage());
            }
        }
        return errors;
    }
}
```

其中BindingResult是返回的校检时的错误信息。由于是POST方法，这里需要借助工具完成，当然也可以自行设计Html界面，这里就不做演示了，如下效果：

![](https://github.com/Lumnca/Spring-Boot/blob/master/img/a39.png)

**分组校检**

如果某一个实体类中定义了很多校检规则，但是在业务处理中定义了很多的校检规则，最后又不用这么多规则就可以使用分组校检

首先创建两个接口：

```java
public interface ValidationGrop1 {
}
interface ValidationGrop2{

}

```

这两个接口不需要添加内容。

接下来就是为校检规则划分组：

```java
    private Integer id;
    @Size(min = 5,max = 10,message = "{user.name.size}",groups = ValidationGrop1.class)
    private String username;
    @NotNull(message = "{user.email.notnull}",groups = ValidationGrop2.class)
    @Email(message = "{user.email.pattern}",groups = ValidationGrop1.class)
    private String email;
    @DecimalMin(value = "1",message = "{user.age.size}",groups = {ValidationGrop1.class,ValidationGrop2.class})
    @DecimalMax(value = "150",message = "{user.age.size}")
    private Integer age;
    public User(){

    }
```


最后在执行上选择分组：

```java
    public List<String> addUser(@Validated(value = ValidationGrop1.class) User user, BindingResult result){
        List<String> errors = new ArrayList<>();
        if(result.hasErrors()){
            List<ObjectError> allErrors= result.getAllErrors();
            for(ObjectError oe : allErrors){
                errors.add(oe.getDefaultMessage());
            }
        }
        return errors;
    }
```


**注解校检**

上面只是简单地提到了几个校检注解，常用的校检如下：

|校验注解|注解的元素类型|描述|
|:--|:--|:---|
|AsernFalse|Boolean，boolcan|被注解的元素值必须为false |
|AsertTrue |Boolean、boolean|被注解的元素值必须为true  |
|Futrue|时间类|必须是一个未来时间|
|Past|时间类|必须是一个过去时间|
|Future（Past）OrPresent|时间类|未来（过去）或者当前时间|
|Negative（OrZero）|数组型|必须为负数（或者为0）|
|Positive|数值型|必须为正数|
|Pattren|指定字符正则式|必须满足的正则式|

:arrow_double_down:[Ftp整合](#a6)

<b id="a6"></b>

### :bowling:整合ftp ###

:arrow_double_up: [返回目录](#t)

有时需要用到ftp服务器的话，需要整合ftp。步骤如下，添加依赖包：

```xml
        <dependency>
            <groupId>commons-net</groupId>
            <artifactId>commons-net</artifactId>
            <version>3.6</version>
        </dependency>
```

然后就可以使用ftp连接了，这里的示例采用了linux的ftp服务器。下面直接封装好了，相关解释见注释：


```java
package com;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.net.ftp.FTPClient;
import org.apache.commons.net.ftp.FTPFile;
import org.apache.commons.net.ftp.FTPReply;

import java.io.*;
import java.util.List;

public class FtpServer {
    /**
     *连接服务器
     * @param addr 服务器IP地址
     * @param port 端口
     * @param username  用户名
     * @param password  密码
     * @param controlEncoding  编码
     * @return
     * @throws Exception
     */
    public static FTPClient connectFtpServer(String addr, int port, String username, String password, String controlEncoding)throws Exception {
        FTPClient ftpClient = new FTPClient();
        try {
            /**设置文件传输的编码*/
            ftpClient.setControlEncoding(controlEncoding);

            /**连接 FTP 服务器
             * 如果连接失败，则此时抛出异常，如ftp服务器服务关闭时，抛出异常：
             * java.net.ConnectException: Connection refused: connect*/
            ftpClient.connect(addr, port);
            /**登录 FTP 服务器
             * 1）如果传入的账号为空，则使用匿名登录，此时账号使用 "Anonymous"，密码为空即可*/
            if (StringUtils.isBlank(username)) {
                System.out.println("匿名连接方式");
                ftpClient.login("Anonymous", "");
            } else {
                ftpClient.login(username, password);
                System.out.println("用户连接方式");

            }
            /*设置传输的文件类型
             * BINARY_FILE_TYPE：二进制文件类型
             * ASCII_FILE_TYPE：ASCII传输方式，这是默认的方式
             * ....
             */
            ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE);

            /*
             * 确认应答状态码是否正确完成响应
             * 凡是 2开头的 isPositiveCompletion 都会返回 true，因为它底层判断是：
             * return (reply >= 200 && reply < 300);
             */
            int reply = ftpClient.getReplyCode();
            if (!FTPReply.isPositiveCompletion(reply)) {
                /*
                 * 如果 FTP 服务器响应错误 中断传输、断开连接
                 * abort：中断文件正在进行的文件传输，成功时返回 true,否则返回 false
                 * disconnect：断开与服务器的连接，并恢复默认参数值
                 */
                ftpClient.abort();
                ftpClient.disconnect();
                System.out.println("连接失败！");
            }
            else {
                System.out.println("连接成功！");
            }
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println(">>>>>FTP服务器连接登录失败，请检查连接参数是否正确，或者网络是否通畅*********");
        }
        return ftpClient;
    }

    /**
     * 使用完毕，应该及时关闭连接
     * 终止 ftp 传输
     * 断开 ftp 连接
     *
     * @param ftpClient
     * @return
     */
    public static void closeFTPConnect(FTPClient ftpClient) {
        try {
            if (ftpClient != null && ftpClient.isConnected()) {
                ftpClient.abort();
                ftpClient.disconnect();
                System.out.println("关闭Ftp服务器");
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * 文件下载
     * @param ftpClient ftp服务器f
     * @param absoluteLocalDirectory 下载文件到本地目录
     * @param relativeRemotePath 下载文件所在ftp位置
     */



    public static void downloadSingleFile(FTPClient ftpClient, String absoluteLocalDirectory, String relativeRemotePath) {
        /**如果 FTP 连接已经关闭，或者连接无效，则直接返回*/
        if (!ftpClient.isConnected() || !ftpClient.isAvailable()) {
            System.out.println(">>>>>FTP服务器连接已经关闭或者连接无效*********");
            return;
        }
        if (StringUtils.isBlank(absoluteLocalDirectory) || StringUtils.isBlank(relativeRemotePath)) {
            System.out.println(">>>>>下载时遇到本地存储路径或者ftp服务器文件路径为空，放弃...*********");
            return;
        }
        try {
            /**没有对应路径时，FTPFile[] 大小为0，不会为null*/
            FTPFile[] ftpFiles = ftpClient.listFiles(relativeRemotePath);
            FTPFile ftpFile = null;
            if (ftpFiles.length >= 1) {
                ftpFile = ftpFiles[0];
            }
            if (ftpFile != null && ftpFile.isFile()) {
                /** ftpFile.getName():获取的是文件名称，如 123.mp4
                 * 必须保证文件存放的父目录必须存在，否则 retrieveFile 保存文件时报错
                 */
                File localFile = new File(absoluteLocalDirectory, relativeRemotePath);
                if (!localFile.getParentFile().exists()) {
                    localFile.getParentFile().mkdirs();
                }
                OutputStream outputStream = new FileOutputStream(localFile);
                String workDir = relativeRemotePath.substring(0, relativeRemotePath.lastIndexOf("/"));
                if (StringUtils.isBlank(workDir)) {
                    workDir = "/";
                }
                /**文件下载前，FTPClient工作目录必须切换到文件所在的目录，否则下载失败
                 * "/" 表示用户根目录*/
                ftpClient.changeWorkingDirectory(workDir);
                /**下载指定的 FTP 文件 到本地
                 * 1)注意只能是文件，不能直接下载整个目录
                 * 2)如果文件本地已经存在，默认会重新下载
                 * 3)下载文件之前，ftpClient 工作目录必须是下载文件所在的目录
                 * 4)下载成功返回 true，失败返回 false
                 */
                ftpClient.retrieveFile(ftpFile.getName(), outputStream);

                outputStream.flush();
                outputStream.close();
                System.out.println(">>>>>FTP服务器文件下载完毕*********" + ftpFile.getName());
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


    /**
     * 遍历 FTP 服务器指定目录下的所有文件(包含子孙文件)
     *
     * @param ftpClient        ：连接成功有效的 FTP客户端连接
     * @param remotePath       ：查询的 FTP 服务器目录，如果文件为空，则视为无效，使用绝对路径，如"/"、"/video"、"\\"、"\\video"
     * @param relativePathList ：返回查询结果，其中为服务器目录下的文件相对路径，如：\1.png、\docs\overview-tree.html 等
     * @return
     */
    public static List<String> loopServerPath(FTPClient ftpClient, String remotePath, List<String> relativePathList) {
        /**如果 FTP 连接已经关闭，或者连接无效，则直接返回*/
        if (!ftpClient.isConnected() || !ftpClient.isAvailable()) {
            System.out.println("ftp 连接已经关闭或者连接无效......");
            return relativePathList;
        }
        try {
            /**转移到FTP服务器根目录下的指定子目录
             * 1)"/"：表示用户的根目录，为空时表示不变更
             * 2)参数必须是目录，当是文件时改变路径无效
             * */
            ftpClient.changeWorkingDirectory(remotePath);
            /** listFiles：获取FtpClient连接的当前下的一级文件列表(包括子目录)
             * 1）FTPFile[] ftpFiles = ftpClient.listFiles("/docs/info");
             *      获取服务器指定目录下的子文件列表(包括子目录)，以 FTP 登录用户的根目录为基准，与 FTPClient 当前连接目录无关
             * 2）FTPFile[] ftpFiles = ftpClient.listFiles("/docs/info/springmvc.txt");
             *      获取服务器指定文件，此时如果文件存在时，则 FTPFile[] 大小为 1，就是此文件
             * */
            FTPFile[] ftpFiles = ftpClient.listFiles();
            if (ftpFiles != null && ftpFiles.length > 0) {
                for (FTPFile ftpFile : ftpFiles) {
                    if (ftpFile.isFile()) {
                        String relativeRemotePath = remotePath + "/" + ftpFile.getName();
                        relativePathList.add(relativeRemotePath);
                    } else {
                        loopServerPath(ftpClient, remotePath + "/" + ftpFile.getName(), relativePathList);
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return relativePathList;
    }



    /**
     * 上传本地文件 或 目录 至 FTP 服务器----保持 FTP 服务器与本地 文件目录结构一致
     *
     * @param ftpClient  连接成功有效的 FTPClinet
     * @param uploadFile 待上传的文件 或 文件夹(此时会遍历逐个上传)
     * @throws Exception
     */
    public static void uploadFiles(FTPClient ftpClient, File uploadFile)throws IOException {
        /**如果 FTP 连接已经关闭，或者连接无效，则直接返回*/
        if (!ftpClient.isConnected() || !ftpClient.isAvailable()) {
            System.out.println(">>>>>FTP服务器连接已经关闭或者连接无效*****放弃文件上传****");
            return;
        }
        if (uploadFile == null && !uploadFile.exists()) {
            System.out.println(">>>>>待上传文件为空或者文件不存在*****放弃文件上传****");
            return;
        }
        try {
            if (uploadFile.isDirectory()) {
                /**如果被上传的是目录时
                 * makeDirectory：在 FTP 上创建目录(方法执行完，服务器就会创建好目录，如果目录本身已经存在，则不会再创建)
                 * 1）可以是相对路径，即不以"/"开头，相对的是 FTPClient 当前的工作路径，如 "video"、"视频" 等，会在当前工作目录进行新建目录
                 * 2）可以是绝对路径，即以"/"开头，与 FTPCLient 当前工作目录无关，如 "/images"、"/images/2018"
                 * 3）注意多级目录时，必须确保父目录存在，否则创建失败，
                 *      如 "video/201808"、"/images/2018" ，如果 父目录 video与images不存在，则创建失败
                 * */
                ftpClient.makeDirectory(uploadFile.getName());
                /**变更 FTPClient 工作目录到新目录
                 * 1)不以"/"开头表示相对路径，新目录以当前工作目录为基准，即当前工作目录下不存在此新目录时，变更失败
                 * 2)参数必须是目录，当是文件时改变路径无效*/
                ftpClient.changeWorkingDirectory(uploadFile.getName());

                File[] listFiles = uploadFile.listFiles();
                for (int i = 0; i < listFiles.length; i++) {
                    File loopFile = listFiles[i];
                    if (loopFile.isDirectory()) {
                        /**如果有子目录，则迭代调用方法进行上传*/
                        uploadFiles(ftpClient, loopFile);
                        /**changeToParentDirectory：将 FTPClient 工作目录移到上一层
                         * 这一步细节很关键，子目录上传完成后，必须将工作目录返回上一层，否则容易导致文件上传后，目录不一致
                         * */
                        ftpClient.changeToParentDirectory();
                    } else {
                        /**如果目录中全是文件，则直接上传*/
                        FileInputStream input = new FileInputStream(loopFile);
                        ftpClient.storeFile(loopFile.getName(), input);
                        input.close();
                        System.out.println(">>>>>文件上传成功****" + loopFile.getPath());
                    }
                }
            } else {
                //上传到ftp指定目录 ftpClient.changeWorkingDirectory("kk");
                /**如果被上传的是文件时*/
                FileInputStream input = new FileInputStream(uploadFile);
                /** storeFile:将本地文件上传到服务器
                 * 1）如果服务器已经存在此文件，则不会重新覆盖,即不会再重新上传
                 * 2）如果当前连接FTP服务器的用户没有写入的权限，则不会上传成功，但是也不会报错抛异常
                 * */
                ftpClient.storeFile(uploadFile.getName(), input);
                input.close();
                System.out.println(">>>>>文件上传成功****" + uploadFile.getPath());
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


    /**
     * 删除服务器的文件
     *
     * @param ftpClient   连接成功且有效的 FTP客户端
     * @param deleteFiles 待删除的文件或者目录，为目录时，会逐个删除，
     *                    路径必须是绝对路径，如 "/1.png"、"/video/3.mp4"、"/images/2018"
     *                    "/" 表示用户根目录,则删除所有内容
     */
    public static void deleteServerFiles(FTPClient ftpClient, String deleteFiles) {
        /**如果 FTP 连接已经关闭，或者连接无效，则直接返回*/
        if (!ftpClient.isConnected() || !ftpClient.isAvailable()) {
            System.out.println(">>>>>FTP服务器连接已经关闭或者连接无效*****放弃文件上传****");
            return;
        }
        try {
            /** 尝试改变当前工作目录到 deleteFiles
             * 1）changeWorkingDirectory：变更FTPClient当前工作目录，变更成功返回true，否则失败返回false
             * 2）如果变更工作目录成功，则表示 deleteFiles 为服务器已经存在的目录
             * 3）否则变更失败，则认为 deleteFiles 是文件，是文件时则直接删除
             */
            boolean changeFlag = ftpClient.changeWorkingDirectory(deleteFiles);
            if (changeFlag) {
                /**当被删除的是目录时*/
                FTPFile[] ftpFiles = ftpClient.listFiles();
                for (FTPFile ftpFile : ftpFiles) {
                    System.out.println("----------------::::" + ftpClient.printWorkingDirectory());
                    if (ftpFile.isFile()) {
                        boolean deleteFlag = ftpClient.deleteFile(ftpFile.getName());
                        if (deleteFlag) {
                            System.out.println(">>>>>删除服务器文件成功****" + ftpFile.getName());
                        } else {
                            System.out.println(">>>>>删除服务器文件失败****" + ftpFile.getName());
                        }
                    } else {
                        /**printWorkingDirectory：获取 FTPClient 客户端当前工作目录
                         * 然后开始迭代删除子目录
                         */
                        String workingDirectory = ftpClient.printWorkingDirectory();
                        deleteServerFiles(ftpClient, workingDirectory + "/" + ftpFile.getName());
                    }
                }
                /**printWorkingDirectory：获取 FTPClient 客户端当前工作目录
                 * removeDirectory：删除FTP服务端的空目录，注意如果目录下存在子文件或者子目录，则删除失败
                 * 运行到这里表示目录下的内容已经删除完毕，此时再删除当前的为空的目录，同时将工作目录移动到上移层级
                 * */
                String workingDirectory = ftpClient.printWorkingDirectory();
                ftpClient.removeDirectory(workingDirectory);
                ftpClient.changeToParentDirectory();
            } else {
                /**deleteFile：删除FTP服务器上的文件
                 * 1）只用于删除文件而不是目录，删除成功时，返回 true
                 * 2）删除目录时无效,方法返回 false
                 * 3）待删除文件不存在时，删除失败，返回 false
                 * */
                boolean deleteFlag = ftpClient.deleteFile(deleteFiles);
                if (deleteFlag) {
                    System.out.println(">>>>>删除服务器文件成功****" + deleteFiles);
                } else {
                    System.out.println(">>>>>删除服务器文件失败****" + deleteFiles);
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}
```

接下来直接调用即可：

```
@RestController
public class index {
    @GetMapping("/hello")
    public String hello(){
        FTPClient ftp =new FTPClient();
        List<String > files = new ArrayList<>();
        try {
            ftp =  FtpServer.connectFtpServer("127.0.0.1",21,"xxx","xxxx","utf-8");
          //  FtpServer.downloadSingleFile(ftp,"F:\\","kk/a.txt"); 
          //  FtpServer.loopServerPath(ftp,"kk",files);
          //  FtpServer.uploadFiles(ftp,new File("C:\\Users\\Administrator\\Pictures\\a.jpg"));
            FtpServer.deleteServerFiles(ftp,"kk/a.jpg");
        }
        catch (Exception e){
            e.printStackTrace();
        }
        finally {
            FtpServer.closeFTPConnect(ftp);
        }
        for (String s: files
             ) {
            System.out.println(s);
        }
        return  "Hello";
    }
}
```
