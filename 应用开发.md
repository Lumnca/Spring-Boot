# :golf:应用开发  #

<b id="t"></b>

:arrow_double_down:[邮件发送](#a1)

:arrow_double_down:[定时任务](#a2)

:arrow_double_down:[批处理](#a3)

:arrow_double_down:[Swagger2](#a4)

<b id="a1"></b>

### :bowling:邮件发送 ###

:arrow_double_up: [返回目录](#t)

邮件发送是一个常用的功能，包括注册时的身份验证，重要通知发送都是都会用到邮件发送。Sun公司提供了JavaMail用来实现邮件发送，但是配置烦琐，Spring中提供了
简化邮箱的配置，下面来看看怎么配置邮件发送：

这里以QQ邮箱为例，首先需要开通POP3/STMP服务或者IMAP/STMP服务，如下：

首先到你的QQ邮箱主页设置开启协议（在设置的账户里面）

![](https://github.com/Lumnca/Spring-Boot/blob/master/img/a31.png)

然后往下翻，到协议设置里开启协议，如下：

![](https://github.com/Lumnca/Spring-Boot/blob/master/img/a32.png)


根据操作会让你发送短信验证，得到验证过后，会给你一个授权码，保存好授权码，后面配置需要使用。

接下来就是搭建环境，引入依赖：

```xml
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>
    </dependencies>
```

修改配置文件参数：

```java
spring.mail.host=smtp.qq.com
spring.mail.port=587
spring.mail.username=724119519@qq.com   --QQ用户名
spring.mail.password=tubzuigsfubqbdjh   --验证码
spring.mail.default-encoding=UTF-8
spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory
spring.mail.properties.mail.debug=true;
```

配置发送邮件的方法

```java
@Component
public class MailServer {
    @Autowired
    JavaMailSender javaMailSender;
    public void sendSimpleMail(String from,String to,String cc,String subject,String content){
        SimpleMailMessage message = new SimpleMailMessage();
        message.setFrom(from);
        message.setTo(to);
        message.setCc(cc);
        message.setSubject(subject);
        message.setText(content);
        javaMailSender.send(message);
    }
}
```

* JavaMailSender 是Spring Boot在MailSenderPropertiesConfiguration类中配置好的，该类在Mail自动配置类MailSenderAutoConfiguration 中导入，因此这里注入JavaMailSender就可以使用了。

* sendSimpleMail方法的5个参数分别表示邮件发送者、收件人、抄送人、邮件主题以及邮件内容。

* 简单邮件可以直接构建一个SimpleMailMessage对象进行配置，配置完成后，通过JavaMailSender将邮件发送出去。

然后添加一个测试即可：

```java
@Controller
public class index {

    @Autowired
    MailServer mailServer;
    @GetMapping("/send")
    public String send(){
        mailServer.sendSimpleMail("724119519@qq.com","1050603098@qq.com","724119519@qq.com",
                "消息推送","测试邮件内容:\n"+new Date().toString()+"发送通知，系统消息。");

        return "发送邮件成功";
    }
}
```

注意信息配置要正确，用户名，发送者，接受者，验证码要正确。

**发送带附件的邮件**

要发送附件需要添加额外的配置：

```java
@Component
public class MailServer {
    @Autowired
    JavaMailSender javaMailSender;
    public void sendSimpleMail(String from, String to, String cc, String subject, String content, File file){

        try {
            MimeMessage mimeMessage = javaMailSender.createMimeMessage();
            MimeMessageHelper message = new MimeMessageHelper(mimeMessage,true);
            message.setFrom(from);
            message.setTo(to);
            message.setCc(cc);
            message.setSubject(subject);
            message.setText(content);
            message.addAttachment(file.getName(),file);
            javaMailSender.send(mimeMessage);
        }
        catch (Exception e){
            e.printStackTrace();
        }

    }
}
```

最后添加一个邮件文件即可：

```java
@Controller
public class index {

    @Autowired
    MailServer mailServer;
    @GetMapping("/send")
    public String send(){
        mailServer.sendSimpleMail("724119519@qq.com","1050603098@qq.com","724119519@qq.com",
                "消息推送","测试邮件内容:\n"+new Date().toString()+"发送通知，系统消息。",new File("F:\\实验室\\a30.png"));
        return "发送邮件成功";
    }
}
```

**发送带图片的资源的邮件**

有的邮件可能需要图片邮件，使用FileSystemResource就可以实现：

```java
@Component
public class MailServer {
    @Autowired
    JavaMailSender javaMailSender;
    public void sendSimpleMail(String from, String to, String subject, String content,
                               String[] srcPath,String[] redIds){
        if(srcPath.length != redIds.length){
            System.out.println("发送失败");
            return;
        }
        try {
            MimeMessage message = javaMailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message,true);
            helper.setFrom(from);
            helper.setTo(to);
            helper.setSubject(subject);
            helper.setText(content,true);   //第二个参数开启HTML内容发送
            for (int i=0;i < srcPath.length;i++){
                FileSystemResource resource = new FileSystemResource(new File(srcPath[i]));
                helper.addInline(redIds[i],resource);
            }
            javaMailSender.send(message);
        }
        catch (MessagingException e){
            e.printStackTrace();
            System.out.println("发送失败");
        }
    }
}
```

接下来就是控制器：

```java
    @Autowired
    MailServer mailServer;
    @GetMapping("/send")
    public void send(HttpServletResponse response ){
        mailServer.sendSimpleMail("724119519@qq.com","1050603098@qq.com","测试邮件带图片发送",
                "<div>测试图片一</div><div><img src='cid:p01'></div>" +
                        "<div>测试图片二</div><div><img src='cid:p02'></div>",
                new String[]{"F:\\实验室\\a28.png","F:\\实验室\\a29.png"},new String[]{"p01","p02"});
        System.out.println("发送成功！");
    }
```

其中cid为静态文件路径配置，其中参数配置了文件路径。

当然可以使用Html模板来构建邮件模板。

<b id="a2"></b>

### :bowling:定时任务 ###

:arrow_double_up: [返回目录](#t)

定时任务也是常见的开发应用之一，定时发送信息，执行某些操作十分重要。简单的定时操作可以直接由注解@Scheduled注解来实现，复杂的定时任务则是由集成Quartz来实现。

**Scheduled**

@Scheduled注解使用简单，如下：

在项目启动类上开启定时启动注解@EnableScheduling

```java
@SpringBootApplication
@EnableScheduling
public class start {
    public static  void main(String[] args){
        SpringApplication.run(start.class,args);
    }
}
```


定时任务主要通过@Scheduled注解进行配置，如下：

```java
    @Scheduled(fixedDelay = 1000)
    public void  printf(){
        System.out.println("定时打印信息");
    }
```

注意方法可以在任何地方执行，不需要调用，一旦开启注解，就会执行。fixedDelay为定时时间，单位毫秒。可以设置开始延迟时间：

```java
    @Scheduled(fixedDelay = 1000,initialDelay = 5000)
    public void  printf(){
        System.out.println("定时打印信息");
    }
```

initialDelay代表开始的延迟时间。当然也可以使用cron表达式来：

```java
    @Scheduled(cron = "0 * * * * ?")
    public void  printf(){
        System.out.println("定时打印信息");
    }
```

**Quatrz**

Quatrz是一个功能丰富的开源作业调度库，它由Java写成，可以集成在任何的Java应用程序中，使用Quatrz可以创建复杂或者简单的执行计划，它又支持数据库，集群，插件以及邮件，并且支持cron表达式，具有极高的灵活性。下面介绍其使用方法：

添加依赖：

```xml
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-quartz</artifactId>
        </dependency>
    </dependencies>
```

创建Job：

```java
public class MyJob  extends QuartzJobBean {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    protected void executeInternal(JobExecutionContext context){
        System.out.println("用户："+name+"打印日期:"+new Date());
    }
}
```

这是不使用注解，而是继承 QuartzJobBean抽象类，当然也可以使用普通类并添加注解@Component，但是这样不能够传递方法参数，推荐使用这种方式。其中 executeInternal方法是任务被调用是启动，name属性在配置文件中配置，接下来完成配置文件：

```java
@Configuration
public class QuartzConfig {
   /*
   *普通类Bean调用方式
   @Bean
    MethodInvokingJobDetailFactoryBean jobDetailFactoryBean1(){
        MethodInvokingJobDetailFactoryBean factoryBean = new MethodInvokingJobDetailFactoryBean();
        factoryBean.setTargetBeanName("MyJob");
        factoryBean.setTargetMethod("printf");
        return factoryBean;
    }*/
    @Bean
    JobDetailFactoryBean jobDetailFactoryBean2(){
        JobDetailFactoryBean bean = new JobDetailFactoryBean();
        bean.setJobClass(MyJob.class);         //--获取执行类
        JobDataMap jobDataMap = new JobDataMap();   //添加参数字段
        jobDataMap.put("name","sang");      
        bean.setJobDataMap(jobDataMap);
        bean.setDurability(true);
        return  bean;
    }
    //---定时操作
    @Bean
    SimpleTriggerFactoryBean simpleTriggerFactoryBean(){
        SimpleTriggerFactoryBean bean = new SimpleTriggerFactoryBean();
        bean.setJobDetail(jobDetailFactoryBean2().getObject());
        bean.setRepeatCount(3);          //执行3次
        bean.setStartDelay(2000);        //任务启动延迟时间
        bean.setRepeatInterval(1000);    //循环调用时间间隔
        return  bean;
    }
    /*
    cron表达式用法
    @Bean
    CronTriggerFactoryBean cronTriggerFactoryBean(){
        CronTriggerFactoryBean bean = new CronTriggerFactoryBean();
        bean.setJobDetail(jobDetailFactoryBean2().getObject());
        bean.setCronExpression("* * * * * ?");
        return bean;
    }
    */
    //添加任务配置
    @Bean
    SchedulerFactoryBean schedulerFactoryBean(){
        SchedulerFactoryBean bean = new SchedulerFactoryBean();
        SimpleTrigger simpleTrigger = simpleTriggerFactoryBean().getObject();  
        bean.setTriggers(simpleTrigger);  //--计时方法配置参数，可多个
        return bean;
    }
}

```

启动运行就可以看到控制台打印3条信息。

<b id="a3"></b>

### :bowling:批处理 ###

:arrow_double_up: [返回目录](#t)

Spring Batch是一个开源的、全面的、轻量级的批处理框架，通过Spring Batch可以实现强大的批处理应用程序的开发。Spring Batch还提供记录/跟踪、事务管理、作业处理统计、作业重启以及资源管理等功能。Spring Batch结合定时任务可以发挥更大的作用。
Spring Batch 提供了ltemReader、ItemProcessor和ltemWriter来完成数据的读取、处理以及写出操作，并且可以将批处理的执行状态持久化到数据库中。接下来通过一个简单的数据复制展示Spring Boot中如何使用Spring Batch。

**整合Spring Boot**

现在有一个data.csv文件，文件件中保存了4条数据，通过批处理框架读取data.csv，将之插入数据表中，首先添加依赖：

```xml
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-batch</artifactId>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid</artifactId>
            <version>1.1.9</version>
        </dependency>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.1.21</version>
        </dependency>
    </dependencies>
```

修改配置文件

```java
spring.datasource.url=jdbc:mysql://47.106.254.86/ex?characterEncoding=utf8&useSSL=true
spring.datasource.username=lumnca
spring.datasource.password=chuan868
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
spring.datasource.driver-class-name=com.mysql.jdbc.Driver

spring.datasource.schema=classpath:/org/springframework/batch/core/schema-mysql.sql  --获取自动脚本

spring.batch.initialize-schema=always 
spring.batch.job.enabled=false   --自动化配置，需要手动执行
```

添加注解@EnableBatchProcessing  对Spring Batch支持

```java
@SpringBootApplication
@EnableBatchProcessing  
public class start {
    public static  void main(String[] args){
        SpringApplication.run(start.class,args);
    }
}
```

首先配置插入数据库的实体类(数据库字段为"id", "username","address","gender")：

```java

public class User {
    private Integer id;
    private String username;
    private String address;
    private String gender;

    public User(){

    }
    public User(Integer _id,String _username,String _address,String _gender){
        id = _id;
        username = _username;
        address = _address;
        gender = _gender;
    }
    public void setUsername(String username) {
        this.username = username;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public Integer getId() {
        return id;
    }

    public String getAddress() {
        return address;
    }

    public String getGender() {
        return gender;
    }

    public String getUsername() {
        return username;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }
}

```

需要插入的data.csv文件：

```csv
id username address gender
1 张三 深圳 男
2 李四 广州 男
3 王五 上海 男
4 陆露 北京 女
```


配置批处理代码：

```java
@Configuration
@EnableBatchProcessing
public class BatchConfiguration {
    @Autowired
    public JobBuilderFactory jobBuilderFactory;

    @Autowired
    public StepBuilderFactory stepBuilderFactory;

    @Autowired
    public DataSource dataSource;

    @Bean
    public FlatFileItemReader<User> reader() {
        FlatFileItemReader<User> reader = new FlatFileItemReader<User>();
        reader.setResource(new ClassPathResource("data.csv"));  //文件所在位置位于resource目录下的data.csv
        reader.setLinesToSkip(1);                               //跳过第一行，因为第一行为表头，不是插入的内容
        reader.setLineMapper(new DefaultLineMapper<User>() {
            {
                setLineTokenizer(new DelimitedLineTokenizer() {
                    {
                        setNames("id", "username","address","gender");  //字段信息，全部添加
                        setDelimiter(" ");                              //字段分隔符，在data.csv文件中以空格隔开
                    }
                });
                setFieldSetMapper(new BeanWrapperFieldSetMapper<User>() {
                    {
                        setTargetType(User.class);    //对应实体类
                    }
                });
            }
        });
        return reader;
    }
    //批处理监听器
    @Bean
    public UserItemProcessor processor() {
        return new UserItemProcessor();
    }
    @Bean
    public JdbcBatchItemWriter<User> writer() {
        JdbcBatchItemWriter<User> writer = new JdbcBatchItemWriter<>();
        writer.setItemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider<>());
        writer.setSql("INSERT INTO user (id,username,address,gender) VALUES (:id,:username,:address,:gender)"); //插入数据库操作，:字段即代表对应字段
        writer.setDataSource(dataSource);
        return writer;
    }
    //作业配置
    @Bean
    public Job importUserJob(JobCompletionNotificationListener listener) {
        return jobBuilderFactory.get("importUserJob")  //对应自己名称
                .incrementer(
                new RunIdIncrementer())
                .listener(listener)
                .flow(step1())
                .end()
                .build();
    }
    @Bean
    public Step step1() {
        return stepBuilderFactory.get("step1")   //对应自己名称
                .<User, User>chunk(2)    //一次性读取2条信息
                .reader(reader())        //读操作绑定
                .processor(processor())  //监听绑定
                .writer(writer())        //写绑定
                .build();              
    }
}

```


接下来就是监听器处理：

```java
public class UserItemProcessor implements ItemProcessor<User, User> {
    private static final Logger log = LoggerFactory.getLogger(UserItemProcessor.class);

    @Override
    public User process(final User user) throws Exception {
        final Integer id = user.getId();
        final String gender = user.getGender();
        final String username = user.getUsername();
        final String address = user.getAddress();
        final User transformedPerson = new User(id,username,address,gender);

        log.info("插入一条数据："+user.getId()+" " + user.getUsername() +" "+ user.getAddress()+" "+user.getGender());
        return transformedPerson;
    }
}
```

已经批处理作业监听器：

```java
@Component
public class JobCompletionNotificationListener extends JobExecutionListenerSupport {
    private static final Logger log = LoggerFactory.getLogger(JobCompletionNotificationListener.class);
    private final JdbcTemplate jdbcTemplate;

    @Autowired
    public JobCompletionNotificationListener(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }
    @Override
    public void afterJob(JobExecution jobExecution) {
        //开始执行触发
        if (jobExecution.getStatus() == BatchStatus.STARTING){
            log.info("开始执行");
        }
        //完成触发
        eles if (jobExecution.getStatus() == BatchStatus.COMPLETED) {
            log.info("添加完成！！！数据报告如下");

            List<User> results = jdbcTemplate.query(
                    "SELECT * FROM user", new RowMapper<User>() {
                        @Override
                        public User mapRow(ResultSet rs, int row) throws SQLException {
                            return new User(rs.getInt(1), rs.getString(2),rs.getString(3),rs.getString(4));
                        }
                    });

            for (User person : results) {
                log.info("在数据库中找到了一条数据：" + person.getUsername() +" "+ person.getAddress()+" "+person.getGender());
            }
        }
    }
}
```

由于我们前面配置的是手动启用这个批处理，所以需要我们自己启动：

```java
@Controller
public class index {
    @Autowired
    JobLauncher jobLauncher;
    @Autowired
    Job job;
    @GetMapping("/hello")
    public String hello(){
        try {
            jobLauncher.run(job,
            new JobParametersBuilder().addString(new Date().toString(),"xxx").toJobParameters());
        }
        catch (Exception e){
            e.printStackTrace();
        }
        finally {
           System.out.println("操作完成！");
        }
        return "Success";
    }
}
```


值得注意的是这里的 jobLauncher.run是启用批处理，这里参数必须添加，参数为键值对，是在批处理中调用的，如果不使用的话，这里可以写任意的键值对，但是键值对的key要保证每次调用都不同，因为作业调度要唯一，这个也是区别不同作业键值对。当然把前面配置文件的spring.batch.job.enabled=false改为ture，就可以在项目启动时自动启用，在数据库中创建好对应的user表，执行接口`http://localhost:8080/hello`看到如下信息：

![](https://github.com/Lumnca/Spring-Boot/blob/master/img/a33.png)

其中包括日志打印信息和我们刚才添加的键值对。

在数据中也能看到对应的数据：

![](https://github.com/Lumnca/Spring-Boot/blob/master/img/a34.png)

至此简单的批处理使用就到这里了，如果想使用高级配置还是比较复杂，可以在网上查找。

<b id="a4"></b>

### :bowling:Swagger2 ###

:arrow_double_up: [返回目录](#t)

在前后端分离开发中，为了减少与其他团队的沟通成本，一般构建一份RESful API文档来描述所有接口信息，但是这种做法有很大的弊端。Swagger2是一个开源软件框架
可以帮助开发人员设计使用，构建，记录和使用RESful Web服务它将代码和文档融为一体，可以完美解决上面的问题。使开发更加便捷。

添加依赖：

```xml
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
            <version>2.9.2</version>
        </dependency>
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger-ui</artifactId>
            <version>2.9.2</version>
        </dependency>
    </dependencies>
```


创建Swagger2配置类：

```java
@Configuration
@EnableSwagger2  //开启Swagger注解
public class SwaggerConfig {
    @Bean
    Docket docket(){
        return new Docket(DocumentationType.SWAGGER_12)   
                .select()
                .apis(RequestHandlerSelectors.basePackage("run"))          //扫描控制器接口的包路径
                .paths(PathSelectors.any())
                .build().apiInfo(new ApiInfoBuilder()
                .description("接口测试文档")                                      //文档命名与地址链接版本信息，标题等信息，可随意
                .contact(new Contact("Lumnca","https://github.com/lumnca","" +
                        "lumnca@gmail.com"))
                .version("V1.1.0")              
                .title("API测试文档")
                .license("Apache2.0")
                .licenseUrl("http://www.apache.org/licenses/LICENSE-2.0")
                .build());
    }
}
```


接下来就可以直接添加接口了，注意上面的接口配置类的包在run下，所以我的接口也应该建立在此之下。创建接口：

```java
@RestController
@Api(tags = "用户数据接口")      //接口信息
public class index {
    @ApiOperation(value = "查询用户",notes = "根据ID查询用户")
    @ApiImplicitParam(paramType = "path",name = "id",value = "用户ID",required = true,defaultValue = "5")
    @GetMapping("/user/{id}")
    public String getUserById(@PathVariable Integer id){
        return "/user"+id;
    }

    @ApiResponses({
            @ApiResponse(code = 200,message = "删除成功！"),
            @ApiResponse(code = 500,message = "删除失败")
    })
    @ApiOperation(value = "删除用户",notes = "通过id删除用户")
    @DeleteMapping("/user/{id}")
    public Integer deleteById(Integer id){
        return  id;
    }

    @ApiResponses({
            @ApiResponse(code = 200,message = "操作成功！"),
            @ApiResponse(code = 404,message = "操作未找到！"),
            @ApiResponse(code = 500,message = "操作失败！")
    })
    @ApiOperation(value = "添加用户",notes = "提供全参数",produces = "JSON")
    @PostMapping("/user/add")
    public String addUser(@RequestBody User info){
        return info.getUsername();
    }
    @ApiIgnore
    public void user(){

    }
}
```

对于上面的注解@ApiOperation用于方法之上，代表对方法接口进行描述，其中value就是描述信息，notes是详细信息。

@ApiImplicitParam注解是参数描述信息(paramType是指方法参数的类型，可选择值有path（参数获取方式@PathVariable），query（参数获取方式@RequestParam），header（参数方法是@RequestHeader），body（@@RequestBody）等来描述，默认自动匹配，required = true表示该字段必须填写，defaultValue表示该字段的默认值。

 @ApiResponses是对接口响应结果进行描述，code为响应码，message为对应的信息。
 
 @ApiIgnore表示不对该方法进行描述。
 
 如果想对实体类进行描述可以添加实体类描述注解：
 
 ```java
 @ApiModel(value = "用户实体类",description = "用户信息描述类")       //实体类注解
public class User {
    @ApiModelProperty(value = "用户ID")       //属性字段信息
    private Integer id;
    @ApiModelProperty(value = "用户名")
    private String username;
    @ApiModelProperty(value = "用户地址")
    private String address;
    @ApiModelProperty(value = "用户性别")
    private String gender;

    public User(){

    }
    public User(Integer _id,String _username,String _address,String _gender){
        id = _id;
        username = _username;
        address = _address;
        gender = _gender;
    }
    public void setUsername(String username) {
        this.username = username;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public Integer getId() {
        return id;
    }

    public String getAddress() {
        return address;
    }

    public String getGender() {
        return gender;
    }

    public String getUsername() {
        return username;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }
}

 ```


完成后，在浏览器地址栏输入`http://localhost:8080/swagger-ui.html`即可以看到接口文档。如下

![](https://github.com/Lumnca/Spring-Boot/blob/master/img/a35.png)

打开接口和实体类信息如下：

![](https://github.com/Lumnca/Spring-Boot/blob/master/img/a36.png)

打开方法输入参数界面：

![](https://github.com/Lumnca/Spring-Boot/blob/master/img/a37.png)

点击执行按钮看到响应信息：

![](https://github.com/Lumnca/Spring-Boot/blob/master/img/a38.png)

