# :golf:Spring Boot 缓存  #

<b id="t"></b>

:arrow_double_down:[Ehcache 2.x缓存](#a1)

:arrow_double_down:[Redis缓存](#a2)

Spring 3.1开始对缓存提供技术支持，核心思路是对于方法的缓存，当开发者调用一个方法时，将方法的参数和返回值作为key-value缓存起来，当再次调用该方法时，如果缓存中有数据，就直接从缓存中获取，否者再执行该方法。但是，Spring并未提供缓存的实现，而是提供了一套缓存API，开发者可以自由选择缓存的实现。下面只介绍Ehcache和Redis缓存。


<b id="a1"></b>

### :bowling:Ehcache 2.x缓存 ###

:arrow_double_up: [返回目录](#t)

在Spring Boot中，只需要一个配置文件就可以将Ehcache集成到项目中，Ehcache 2.x使用步骤如下：

添加依赖：

```xml
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-cache</artifactId>
        </dependency>

        <dependency>
            <groupId>net.sf.ehcache</groupId>
            <artifactId>ehcache</artifactId>
        </dependency>
```

添加配置文件

如果Ehcache的依赖存在，并且在classpath下有一个名为ehcache.xml的配置文件，那么EhcacheCacheManager将会自动作为缓存的实现。因此在resource目录下创建ehcache.xml文件作为Ehcache配置文件，代码如下：

```xml
<ehcache>
    <diskStore path="java.io.tmpdir/cache"/>
    <defaultCache
        maxElementsInMemory="10000"
        eternal="false"
        timeToIdleSeconds="120"
        timeToLiveSeconds="120"
        overflowToDisk="false"
        diskPersistent="false"
        diskExpiryThreadIntervalSeconds="120"
    />
    <cache name="book_cache"
           maxElementsInMemory="10000"
           eternal="true"
           timeToIdleSeconds="120"
           timeToLiveSeconds="120"
           overflowToDisk="true"
           diskPersistent="true"
           diskExpiryThreadIntervalSeconds="600"
    />
</ehcache>
```

如果想更改默认位置，可以在配置文件中添加如下：

```
spring.cache.ehcache.config=classpath:文件url
```

开启缓存

在启动类上加上注解：

```java
@EnableCaching
@SpringBootApplication
public class start {
    public static  void main(String[] args){
        SpringApplication.run(start.class,args);
    }
}
```

创建BookServer：

```java
@Service
@CacheConfig(cacheNames = "book_cache")
public class BookService {
    @Cacheable
    public Book getBookById(Integer id){
        System.out.println("getBookById");
        Book book = new Book(id,"三国演义","罗贯中");
        book.setId(100001);
        return book;
    }
    @CachePut(key = "#book.id")
    public Book updateBookById(Book book){
        System.out.println("updateBookById");
        book.setName("三国演义X");
        return  book;
    }
    @CacheEvict(key = "#id")
    public void deleteBookById(Integer id){
        System.out.println("deleteBookById");
    }
}
```

在BookDao上添加@CacheConfig注解指明使用的缓存的名字，这个配置可选，若不使用@CacheConfig 注解，则直接在@Cacheable注解中指明缓存名字。

在getBookById方法上添加@Cacheable注解表示对该方法进行缓存，默认情况下，缓存的key是方法的参数，缓存的value是方法的返回值。当开发者在其他类中调用该方法时，首先会根据调用参数查看缓存中是否有相关数据，若有，则直接使用缓存数据，该方法不会执行，否则执行该方法，执行成功后将返回值缓存起来，但若是在当前类中调用该方法，则缓存不会生效。

@Cacheable注解中还有一个属性condition用来描述缓存的执行时机，例如@Cacheable（condition="#id%2-0”）表示当d对2取模为0时才进行缓存，否则不缓存。
如果开发者不想使用默认的key，也可以像第13行和第19行一样自定义key，第13行表示缓存的key为参数book对象中id的值，第19行表示缓存的key为参数id。除了这种使用参数定义key的方式之外，Spring还提供了一个root对象用来生成key，如。

|属性名称|属性描述|用法示例|
|:-:|:--|:--------------|
|methodName| 当前方法名|#root.methodName|
|method|当前方法对象|#root.method.name|
|caches|当前方法使用的缓存|#root.caches[0].name|
|target|当前被调用的对象|#root.target|
|targetClass|当前被调用的对象的class |#root.targetClass|
|args|当前方法参数数组|#root.args[0]|

创建测试类：

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class Test01Application {

    @Autowired
    TestServer testServer;
    @Autowired
    WebApplicationContext wac;
    MockMvc mockMvc;
    @Before
    public void before(){
        mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();
    }
    @Autowired
    BookService bookService;

    @Test
    public void contextLoads(){
        bookService.getBookById(1);
        bookService.getBookById(1);
        bookService.deleteBookById(1);
        Book b1 = bookService.getBookById(1);
        System.out.println("b1:"+b1.getName());
        Book b = new Book(1,"三国演义","罗贯中");
        bookService.updateBookById(b);
        Book b2 = bookService.getBookById(1);
        System.out.println("b2"+b2.getName());

    }
}
```

最后执行该测试方法，可以看到如下输入：

```
getBookById
deleteBookById
getBookById
b1:三国演义
updateBookById
b2三国演义X
```

相同的方法没有输出，这是由于缓存导致的，第三行又出现是由于del方法上添加了注解删除这个类容导致。
